---
tags:
  - daily
---

### AOJ

### leetcode
### type-challenge

### Zenn執筆

### 個人開発

[TypeScript の satisfies 演算子は何に役立つのか](https://9sako6.com/posts/why-typescript-satisfies-operator)
型推論結果を残しつつ、型を満たすかどうかをチェックできる

具体的な活用方法について、あとで読む
[【TS】satisfiesじゃないとできないこと。\~無駄な変数を撲滅する\~。](https://zenn.dev/gemcook/articles/17f7a25dc88cb9)
[TypeScript 4.9のas const satisfiesが便利。型チェックとwidening防止を同時に行う](https://zenn.dev/tonkotsuboy_com/articles/typescript-as-const-satisfies)

https://api.spotify.com/v1/albums/0gB3AKAUJHTWqUzxdqXDxg/tracks?offset=0&limit=50
albums/{id}/tracks エンドポイントでなぜかavailable_marketsが表示されない
APIのバグ
仕方ないので、集めたtracksのidを使って
/tracks エンドポイントでまとめてリクエストして情報を得るしかない

migrateしても変化なし
[removing \`@unique\` in \`schema.prisma\` does not generate ...](https://github.com/prisma/prisma/issues/12732)
外部キーをuniqueにしているとき、prisma migrateしても変更を検知しないので手動で
マイグレーションファイルを作る必要がある
これはOSSコミットできるチャンスなのでは？

まず一時的に`SpotifyTrack_apSongId_fkey`を削除
`SpotifyTrack_apSongId_key` インデックスを削除。
`SpotifyTrack_apSongId_fkey`を再追加
これはマイグレーションファイルを参考にする
```sql
-- 一時的に外部キー制約を解除
ALTER TABLE
  `SpotifyTrack` DROP FOREIGN KEY `SpotifyTrack_apSongId_fkey`;

-- delete unique index
ALTER TABLE
  `SpotifyTrack` DROP INDEX `SpotifyTrack_apSongId_key`;

-- AddForeignKey
ALTER TABLE
  `SpotifyTrack`
ADD
  CONSTRAINT `SpotifyTrack_apSongId_fkey` FOREIGN KEY (`apSongId`) REFERENCES `APSong`(`id`) ON DELETE RESTRICT ON UPDATE CASCADE;
```

albumの中に、既に追加したtrackが入っていたらどうする？

APのアニメタイトルは手入力？
Attack on Titan: The Final Season Part 3
AnilistもMALもこの表記ではない
キャプテン翼などの表記は大体一致する
大体一致しているかどうか？の判定にウェブ検索を利用するアイデア
完全一致の場合は不要だが、一致するタイトルが見つからない場合がある
https://search.brave.com/search?q=Attack+on+Titan%3A+The+Final+Season+Part+3+site%3Amyanimelist.net%2F&source=web
braveで、myanimelistに限定して検索する
ここからMALのidが絞り込める場合がある
https://search.brave.com/search?q=Attack+on+Titan+site%3Amyanimelist.net%2Fanime&source=web
`site:myanimelist.net/anime`のようにルートを絞り込んで検索も可能
ここの上位5件ぐらいのidを取得すれば、animetheme dbと結びつけることができ、
そこから曲名の完全一致検索ができれば（OP,EDに限る）かなり高い精度でアニメを絞ることができる
曲名の完全一致検索ができなくとも、ウェブ検索結果上位5件のアニメと紐づけてしまえばそこまで間違いは起きないはず

超難問
検索結果が非常に多い場合、無限スクロールの解消は簡単だが、
ローディングスケルトンを消す作業が非常に難しい
上から順にスクロールしてロードしていっても、ページ上部のスケルトン表示がまた復活してしまうので無限ループになる
解決策２つ

- スクロールでのページ読み込み、DBデータ作成を並行して行う
これはリーダブルコードではコードの断片化としてバッドプラクティスになっている

- スクロールでのページ読み込みを改善して、スクロール即データインプットを繰り返す
最初に無限スクロールで全項目を表示したら、apsong要素一つ一つに上から番号をつける

index 0 ~ 最初のanimate-pulseが付いている要素までapsongをスクレイピング
最初のanimate-pulseまでスクロールして移動
animate-pulseがついている要素を再度取得。
現在のindexより大きい要素でかつanimate-pulseがついている要素までapsongをスクレイピング
そのanimate-pulseまでスクロールして移動
...
こんな感じの処理を繰り返してページのしたまでたどり着き、全てスクレイピングできれば成功

もしくはもっと単純に1ページ表示単位毎にスクロールして、
大体曲10個分下の要素までスクロール、そこまでの曲をスクレイピングする
とかでも良い

### Terraform / AWS

### Frontend Mentor

### React Testing

### Obsidian研究

### その他
